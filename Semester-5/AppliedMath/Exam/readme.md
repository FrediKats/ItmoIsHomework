# Проект. Планирование движения материальной точки

В качестве темы для проекта по предмету "Методы оптимизации" был выбран 15-ый вариант: Планирование движения материальной точки с использованием эволюционного программирования (генетический алгоритм с мутациями).

# Постановка задачи
## Теоретическая формулировка

Материальная точка (робот) массы m = 1 покоится в точке A(0,0) плоскости 0xy. Нужно привести робота в точку B(1,1) и остановиться в ней за минимальное время. Роботу запрещается покидать квадрат [0,1] × [0,1], также роботу запрещается заезжать в круги вида $(x − X_j)^2 + (y − Y_j)^2 <= R_j^2$.
На робот действует единственная сила F, величину и направление которой мы можем произвольно изменять $|F| < F_{max}$.

## Данные

Входные данные алгоритма:
- максимальная сила F_{max}
- шаг времени d_t
- центры помех $P_j(X_j, Y_j)$ и радиусы $R_j$.

Выход алгоритма:
- последовательность значений сил в каждый момент времени: $F_{xk}, F_{yk}$.

## Полигон для тестирования

Перед тем как начать разработку алгоритмов, нужно реализовать возможность визуализации результатов выполнения. Во-первых, это упростит работу с восприятием результатов. Во-вторых, графическое представление дает возможность пользователю проанализировать ответ на наличие дефектов, выяснить их источники, что сделать анализатором на уровне программы намного сложнее.

По условию задачи, используется закрытая область $1х1$. Это значит, что все координаты будут вещественными и для отображения нужно вводить ограничения точности.

Отображение результата выполнения выполняется следующим образом:
1. Область пользовательского интерфейса закрашивается черным квадратом (далее - Поле). Допускается, что сторона является единицей измерения.
2. Для каждой зоны генерируется множество точек, которые описывают круг вокруг этой зоны. Эти точки задаются координатой $x,y\in[0;1]$ и в масштабе отображаются на поле.
3. Выбирается интересующий путь, который представлен набором точек и по одно отображается на поле.

# Решение применением только генетического алгоритма

В первом приближении, предполагаем, что можно взять случайный набор команд и оптимизировать его генетическим алгоритмом по средствам мутации. Данное решение будет является достаточно абстрактным и не требовательным к дополнительной логике генерации решения.

Перед выбором способа формализации алгоритма под генетические изменения, нужно определить как алгоритм влияет на решение, какая информация при этом предоставляется. Рассмотрим простой случай: управляемый объект находится в точке $(x_i, y_i)$ и ждет команды алгоритма. Зная все решения, которые были приняты на прошлых шагах, можно посчитать также направление и скорость объекта.

Рассмотрим два подхода к представлению алгоритма в данной задачи:
1. Сгенерируем цепочку команд, которая будет применяться на объект до тех пор, пока алгоритм не закончит выполнение.
2. Создадим зависимость принятого решения от данных, которые предоставляются на каждом шаге $f_i(p_i, v_i)$.

Анализируя первый способ, можно прийти к заключению, что его обучение не является достаточно эффективным: если есть набор принимаемых решений на каждом шаге (в нашем случае $f_i$), то небольшое изменение первого решения может сильно исказить эффективность всех следующих.

Второй способ позволит не зависеть от принятых решений в прошлом, а смотреть только на текущее состояние. Это позволит сделать сделать итоговое решение задачи более устойчивым при изменении одного элемента.

Основные недостатки такого подхода заключаются в том, что для всех пар $(p_i, v_i)$ нужно хранить решение. Т.е. количество генов очень большое и, с большой вероятностью, избыточно для отдельно взятого решения. Помимо расходов памяти для алгоритма, это чревато очень медленным процессом мутации так, как вероятность изменения каждого гена очень мала.

## Формализация задачи к теории генетических алгоритмов

Введем основные понятия [1, с. 126]:
- Ген - атомарный элемент генотипа и/или хромосомы
- Хромосома - упорядоченный набор генов
- Генотип - набор хромосом данной особи
- Аллель - значение конкретного гена, значение его свойства
- Особи - хромосомы с закодированными в них параметрами задачи
- Популяция - множество особей

Стоит отметить, что в классических гены представлены значением {0, 1}, то есть хромосомы - двоичные вектора. Но это не строгое ограничение, в тех же эволюционных алгоритмах используются действительные числа в качестве значений генов [1, с. 207-208].

Для выбранного алгоритма, хромосомой будет набор генов, каждый их которых сопоставляется какому-то набору $(p_i, v_i)$. Для представления данных в программе, значения $p_i$ округляются до какого-то $\epsilon$. Таким образом, хромосома - это закодированный двумерный массив генов. Каждый ген представляет два значения: $(f_x, f_y)$, т.е. вектор силы, который нужно приложить.

В качестве начальной хромосомы берется случайный набор генов.

Одной из ключевых проблем данной задачи является выбор фитнес функции. Ввиду того, что Адамовой хромосомой является набор случайных геной, который почти всегда не является решением, на первом шаге стоит взять такую функцию, чтобы она выбирала в качестве лучших такие хромосомы, что являются максимально близкими к решению. Например, такой функцией является $f(p) = |(1, 1) - p|$, т.е. расстояние последней точки  до таргетной позиции.

Определимся с генетическими операциями, который выполняются над данной популяцией. Так как фитнес функция уже определена, на ее основе можно выделить методы селекции. В данном случае была применена Элитная селекция _(Truncation selection)_. Данный вид селекции подразумевает, что все хромосомы будут упорядоченны по значению фитнес-функции и из них будут выбраны N-лучших.

Для всех полученных хромосом применяется генетический оператор. В нашем случае это простой оператор мутации - их хромосомы выбирается случайный ген и его значение заменяется на случайное подходящее значение. То есть, помимо исходной хромосомы появляются еще ее несколько мутированых потомков. Таким образом из набора хромосом, которые остались после селекции создается новая популяций.

## Процесс вычисления фитнес функции 

Как было указано ранее, в качестве фитнес функции было выбрана функция расстояния до таргетной позиции. Рассмотрим процесс выполнения симуляции.

В начале выполнения объект ставится на начальную позицию (0, 0). На каждом шаге делается проверка - находится ла объект внутри зоны, за пределами поля или в точке (1, 1). Если хотя бы одно условие выполняется - выполнение симуляции заканчивается, возвращается информация о последней посещенной точке. Если же проверка не проходится, то выполняется один шаг. Под шагом подразумевается взятие из хромосомы нужного гена, получение с него информации и применение. Так как хромосома представляет собой зависимость $f(p_x, p_y)$, то по положению объекта в данный момент можем получить вектор силы, который нужно применить. Изменение состояния объекта:  
$$
F = chromosome[p_x, p_y] \\
v = v + a\cdot F\cdot\Delta t \\
p = p + v\cdot v\cdot\Delta t
$$

Таким образом получаем новое положение объекта и для него продолжается выполнение алгоритма. Также стоит отметить наличие верхней границы длительности выполнения т.к. рандомная хромосома может иметь такой набор генов, что построение маршрута по нему будет выполняться бесконечно долго.

## Примеры и результат

При отображении результаты выполнения рандомно сгенерированной хромосомы, скорее всего будет полученная странный маршрут который к тому же может закончится в самом начале. Но выполнение нескольких итерация генетического алгоритма можно получить что-то очень похожое на решение:  
![Выполнение ген алго](img/img_1.jpg)

Дальнейший запуск алгоритма можем сгенерировать путь к конечной точке:  
![Выполнение ген алго](img/img_2.jpg)

Рассмотрим поведение алгоритма после добавление зон. Если хоть одна зона будет находится на пути объекта до ранее успешный алгоритм начнет показывать очень плохие показатели фитнес функции. Но при существовании не сложных маршрутов к конечной точек, данный алгоритм все же сможет воссоздать такую хромосому, которая сможет обходить зоны:  
![Выполнение ген алго](img/img_3.jpg)  
![Выполнение ген алго](img/img_4.jpg)

## Анализ и изменения

Был проведен ряд различных изменений данного способа с целью получить более приспосабливающуюся систему при этом не меняя полностью логику. Можно выделить два основных, которые действительно позитивно сказались на результате. Во-первых, как было определенно вначале, в каждый момент времени при принятии решения известно два значений - позиция и вектор скорости. Было принята попытка построить зависимость  $f(p_x, p_y, |v|)$ используя информацию о скорости. От позволило в одной позиции принимать более правильное решение в зависимости от скорости. Хотя в большинстве случаев данных подход помогал находить решения, а мутации не так часто приводили алгоритм к значительному понижению значения фитнес-функции, ччевидным минусом данного подхода стало значительное удлинение гена и как следствие - замедление обучения.

Второй подход заключался в замене поля поделенного на квадраты на определение полярных координат. Это значит, что в момент принятия решения у объекта определялись два параметра - расстояние до конечной точки и угол между прямой и границей поля. Перед тем как переходит к анализу данного подхода, рассмотрим графическое представление такого деления:  
![Выполнение ген алго](img/img_5.jpg)  
Основная идея заключается в увеличении плотности секторов при приближении к выходу. Ввиду очень больших проблем с остановкой объекта в конечной точности, было выдвинуто предположение, что при упрощенном моделировании именно это и есть основной проблемой алгоритма.

Сравнив эти три подхода (первоначальный, с использованием скорости и с использованием полярных координат) было сделано ряд выводов. Основная проблема использования скорости как параметра - удлинение хромосом и замедление обучения. Полярные координаты являются лишь другим способом представления зависимости принятого решения от координаты и не влечет за собой усложнений процесса обучения. После ряда тестов с использованием небольшого количества зон, именно этот подход показывал более быстрое обучение и лучшие результаты. Основным недостатком является то, что при наличии большого количества зон в начале пути, обучатся алгоритму будет очень трудно 

## Общий вывод по данному подходу

Хотя изложенный ранее алгоритм может находить решения, это не является хорошим решением. Выделим основные недостатки. Во-первых, хромосома представляет собой **довольно большую структуру**, из которой, при построении одного отдельно взятого маршрута, используется лишь некая часть. Следствием этого является не только **медленная мутация**, а также и огромные **расходы памяти**. Также было выявлено, что выбранная **фитнес-функция** лишь на первый взгляд кажется хорошей. Во время обучения были выявлены типичные ситуации, которые обрекали алгоритм на безрезультатные попытки хоь немного исправить ситуацию - это **тупики** созданные зонами. Маршрут, который доходит почти к выходу, но не имеет ни малейшего шанса продвинутся дальше, является более приоритетным в данной модели.

Важным моментом является то, что для оптимизации решения нужно иметь хотя бы какое-то верное. Ввиду того, что за Адамову хромосому в данном подходе выбирался набор раномных генов, первая часть обучения заключалась как раз в построении решения которое удовлетворило условию задачи. При проектировании данного алгоритма была выдвинуто предположение, что это генетический алгоритм мутациями будет быстро справляться  с данной задачей, но на практике оно себя не оправдало.

Из этого можно сделать некоторые выводы.
Мутации данных хромосом проходили очень медленно и не заметно. Наступали моменты, когда да длительном интервале не происходило никаких изменений результата фитнес-функции. На данную ситуацию можно повлиять применив другие алгоритмы мутации. Например, Scramble-мутацию. Основная идея данного способа мутации - брать отрезки хромосомы и каким-то образом их перемешивать или делать реверс.[2, с. 32]

Помимо мутации, можно изменить алгоритм селекции. Основная проблема выбранного способа селекции - очень быстро с популяции исчезают особи, которые хотя бы немного хуже фаворита. Таким образом, весь алгоритм начинает строится вокруг хорошо составленного рандома на первых итерациях. Это плохо сказывает на дальнейшем развитии. Ярким примером тому является невозможность выхода из тупиковой ситуации. Для того, чтобы замедлить процесс отсева менее результативных генотипов, можно использовать алгоритмы селекции на вероятности - "Roulette Wheel"-селекция [3]. Идея заключается в том, чтобы по значениям фитнес-функции давать генотипам шанс попадания в следующую популяцию. Но если если этого будет недостаточно, то можно пойти дальше и использовать пул генотипов - разбивать популяцию на несколько частей, в которых и будет проходить селекция. То есть, это будут независимые наборы генотипов, которые соревнуются между собой. При выявлении пула не способного к дальнейшему развитию - его можно полностью удалять и заполнять случайно взятыми особями из других пулов.

Важно отметить, что в данной реализации не было использовано алгоритмов кросс-овера (скрещивания). Это еще один способ влияния на эффективность обучения. Алгоритмы кросс-овера заключаются в генерации новых хромосом на основе двух или более уже существующих, которые считаются хорошими. Одни из таких алгоритмов является "two point crossover". Описание алгоритма: берутся две хромосомы и два локуса, которые делят хромосому на 3 части. Создаются два потомка, первый будет состоять из первой и третьей частей первого родителя и второй части второго родителя. Второй соответственно наоборот [1, с. 162]. Таким образом можно получить гены двух родителей, которые будут синергировать и в сумме давать результат лучше чем у тех же родителей.

Возможно важнейшим пунктом оптимизации является использование заранее сгенерированного маршрута. Как было сказано ранее, для генетического алгоритма было проблемно случайными изменениями построить валидный путь. Если решить эту проблему за него и запускать мутации на уже готовом но не оптимальном маршруте, можно получить эффективное обучение и улучшение показателей.

# Построение базового решения задачи
## Алгоритм решения проблемы

Главной особенностью данной задачи является наличие зон. Но именно эти зоны и формируют маршрут объекта. Не сложно доказать, что оптимальный маршрут будет обходить по контурам зон (исключением будет является прямой маршрут по диагонали). Это значит, что для решения проблемы построения базового решения можно попытаться построить такой маршрут, который будет связывать начальную точку, несколько зон и конечную точку.

В качестве алгоритма подбора зон был выбран полный перебор: берется $i-ая$ зона, прокладывается прямой путь от начала до нее. Единственное условие - это путь не должен пересекать другие зоны. Любое из полученных данным способом решение можем быть взято в качестве базового решения для задачи.

## Векторизация решения

Описанным ранее алгоритмом построения решения можно получить информацию о зонах через которые нужно пройти, но это никак не накладывается на постановку задачи, где важен не только путь, а еще скорость и сила прикладываемая к объекту. Появляется задача конвертации базового решения в корректный вид ответа.

На первом шаге, переведем все соединяющие линии в набор точек. Начнем с отрезка между началом и первым кругом. Но для его построения нужно выбрать точку на круге. Такой точкой может быть ближайшая точка от начала отрезка к кругу. Для ее построения соединяются начальная точка и центр круга и берется та часть, которая в зону не входит. Следующей проблемой является построение отрезка между двумя кругами. По аналогии можно сделать отрезок между кругами, но остается вопрос в соединении точек двух отрезков - который идет к зоне и который с нее выходит. Очевидно, что это две точки на окружности, а значит изменением угла можно провести дугу по контуру круга, которая соединит их. Например, взять за начальный угол $arctan(y_i/x_i)$, а за конечный $arctan(y_j/x_j)$.

Таким образом для любого подходящего набора зон можно построить маршрут от начальной точки до конечной. Но отрезки не являются корректным ответом в данной постановке задачи.

Приведем построенный набор отрезков к набору точек. Каждый отрезок будем делить на два под отрезка пока его длинна больше условного $\epsilon$. Выбираем точки на концах этих отрезков - они и будут точечным представлением первоначального отрезка. В случае дуг ситуация иная. Взяв произвольный угол мы можем по нему узнать находится ли он между двумя другими, а также получить точку на круге, которая соответствует этому углу. ТАким образом, можно итерироваться в значениях угла между начальным и конечным и с какой-то дискретностью расставлять точки дуги.
Пример построенного таким образом маршрута:  
![Построение базового решения](img/img_6.jpg)  

Выполнив эти действия для всех отрезков входящих в базовое решение, получим окончательный набор точек, который является решением. Именно его и можно использовать при представлении ответа в виде набора векторов.

Перейдем к выражению ответа список приложенных сил. Чтобы это сделать, для каждой пары последовательно идущих в наборе точек применяется такой алгоритм:
1. Вычисляется расстояние между точками (A, B)
2. Вычисляется какое нужно ускорение, чтобы за $\Delta t$ точка переместилась из первой во вторую.
3. Если длинна вектор ускорения превышает ограничение условия задачи, то между этими точками ставим еще одну точку C, которая будет лежать между ними.
4. Начинаем выполнять этот алгоритм сначала для точек (A, C), а потом для (C, B)

В результате данного алгоритма будет получен результирующий набор векторов сил. Это и является ответом на поставленную задачу.

# Сглаживание и оптимизация

Очевидно, что построенный таким образом ответ не является оптимальным. Нужно ввести ряд операция, которые могут перераспределить точки. Вводим предположение, что описанный выше алгоритм вычисления векторов для движения между точки является оптимальным. Если это так, то мы можем строить новые маршруты между точки пропуская некоторые, что лежат между ними. По такому принципу и организованно сглаживание в рамках данного решения. Из всего набора точек, по которым проходит объект, выбирается случайно одна и удаляется. Алгоритм построения набора векторов запускается еще один раз. Возможные ситуации:
1. Была удалена не оптимальная точка. Такая, что по результирующему набору можно построить маршрут и он будет на один шаг оптимальнее
2. Была удалена такая точка, что между двумя соседними нельзя сделать перемещение за один шаг. В этом случае, алгоритм подберет новую точку C, которая будет как минимум не хуже удаленной.

Таким образом, процесс удаления точек будет по шагам оптимизировать построенный маршрут.

## Проблема замедление движения

Во время тестирования алгоритма было выявлено несколько дефектов. Основной из них - установка нулевой скорости объекта. При построении базового маршрута в него включается большое количество точек с небольшим интервалом. Таким образом, легко строится маршрут между ними. В процессе удаление точек расстояние между соседними увеличивается, а соответственно увеличивается скорость. На каждой итерации скорость увеличивается тем самым отдаляя объект от возможности добраться с минимальной скоростью к выходу. Чтобы предотвратить такое поведение, можно ввести верхнюю границу допустимой скорости. Данное значение можно определить как максимальную скорость с которой можно остановится, если двигаться к конечной точке. Для упрощения, вычислять будем обратное: какую максимальную скорость можно получить если ускорятся с конечной точки, до текущей:
$$ l = at^2/2 \\
t = \sqrt{2l/a} \\
v = at = a\sqrt{2l/a} = \sqrt{2l\cdot a}$$
Таким образом, зная расстояние до конечной точки и максимальное ускорение, можно определить моменты, когда скорость превышает допустимую, то проводится хитрый трюк с неоптимальным но простым ограничением - высчитывается такое ускорение, которое нужно приложить, чтобы по окончанию шага скорость приравнялась к максимально допустимой:
$$ v_{max} = -\sqrt{2l\cdot a_{max}} \\
v_{current} + a\cdot t = v_{max} = -\sqrt{2l\cdot a_{max}} \\
a = \frac{-(v_{current} + -\sqrt{2l\cdot a_{max}})}{t}
$$

После добавления данного механизма пересчета скорости, можно наблюдать такие результаты (для наглядности был добавлен график, который демонстрирует как изменяется длинна вектора скорости).  
![Построение базового решения](img/img_8.jpg)  
При первом запуске алгоритма прокладывается тривиальный маршрут. Посмотрев на график скорости можем наблюдать пики и участки со странно изменяющеюся скоростью. Сопоставив данные было выяснено, что пики - это прямые отрезки. Как было сказано ранее, при генерации маршрута по точкам, отрезок делится на точки с константным расстоянием между ними. А значить, чтобы за одинаковое расстояние добраться с i-ого к i+1-ому, нужна одинаковая скорость. Иными словами, объект разгоняется чтобы добраться до первой точки и дальше по инерции с этой скоростью проходит прямую. После этого он переходит к обходу круга, что изображено на графике толстой полосой. На самом деле это наложение которое создается из-за очень частого изменения скорости вверх-вниз.

Перейдем к рассмотрению результат после большого количества итераций алгоритма. Сам маршрут особо не изменился, но было обнаружено несколько особенностей работы. Во-первых, как видно из графика скорости, оптимизация изменила в основном прямые отрезки. На рисунку отчетливо видно это видно - появились пропуски между точками остановки. Во-вторых, по нагромождению точек заметно, что оптимизация уперлась в обход дуг зон.
![Построение базового решения](img/img_7.jpg)  

## Вывод по алгоритму сглаживания

Разработанный алгоритм как минимум решает задачу и делает это намного лучше чем генетический алгоритм на случайных решениях, который описан в первой части. Решение полученное таким способом вовсе не идеал. Это связанно не только с не оптимальными способами обхода зон, но и некоторыми мелкими деталями реализации (к примеру, обход этих зон выполняется строго по часов стрелке хотя это не всегда оптимально).
В целом, подобный подход можно использовать для решения данной задачи, но анализа, геометрии и физики туда куда больше чем самой логики генетического алгоритма.

# Использованная литература

1. Рутковская. - Нейронные сети, генетические алгоритмы и нечеткие системы
2. Bence Keresztury - Genetic algorithms and the Traveling Salesman Problem (url: https://web.cs.elte.hu/blobs/diplomamunkak/bsc_alkmat/2017/keresztury_bence.pdf)
3. Daniel W. Dyer - Evolutionary Computation in Java (url: https://watchmaker.uncommons.org/manual/ch03s02.html)