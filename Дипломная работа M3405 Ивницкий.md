<!-- 1. RPC
2. Написать где-то, что прокси может быть балансировщиком
3. Написать про сравнение с GraphQL -->

<!-- 10. ПОдписать элементы UML
11. Убрать у базы артефакт
14. Описать про TCP и про безопасность -->

## Дипломная работа студента M3405, Ивницкого Алексея на тему "Разработка библиотеки для реализации контрактно-ориентированной модели взаимодействия с базой данных в клиент-серверной системе"

## План
0. Определения
1. Описание предметной области
   1. Особенности поддержки API в клиент-серверной архитектуре
   2. Модель клиент-серверного взаимодействия в продукте Veeam Backup and Replication
   3. Функциональные и не функциональные требования
   4. Существующие решения
2. Архитектура библиотеки 
   1. Описание спецификации
   2. Программная архитектура. Контрактно-ориентированное взаимодействие
   3. Схема размещения компонентов системы
   4. Описание работы системы на стороне клиента
   5. Интеграция с инфраструктурой Veeam Cloud Connect
   6. Стек технологий
3. Реализация
   1. Схема размещения компонентов системы
   2. Механизм построения запросов
   3. Генерация SQL-запросов по разработанной спецификации
4. Кодогенерация инфраструктуры
   1. Roslyn
   2. Применение кодогенерации
   3. Использование SQL-скрипта для анализа схемы базы
   4. Использование метаинформация про базу данных для анализа схемы
   5. Кодогенерация инфраструктурных компонент
5. Литература

# Раздел 0. Определения
<!-- > TODO:1 Возможно, в тексте есть много англицизмов. Например - спека. Нужно будет потом вычитать. -->

> TODO: Дописать определения связанные с инфраструктурой Veeam: бекап, джоба, провайдер.

- .NET - платформа для разработки, включающая общеязыковую исполняющую среду (Common Language Runtime, CLR), которая управляет выполнением кода и обеспечивает создателей программ богатыми библиотеками классов для написания приложений. [@ПР, c. 48]
- .NET standard - это спецификация для набора API, который будет реализован всеми платформами .NET. .NET Standard 2.0 реализована в последних версиях .NET Framework, .NET Core и Xamarin. .NET Standard 2.0 добавляет многие из недостающих API, которые требуются разработчикам для портирования старого кода, написанного под .NET Framework, на платформу. [@ПР, с. 50-51]
- API - программный интерфейс приложения; описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой.  
- СУБД
- Visual Studio - интегрированная среда разработки (IDE) предоставляемая Microsoft. Данная IDE разрабатывает во многом для фреймворка .NET и его языков (C++/CLI, C#, F#), но также имеет поддержку и тулзы для работы с SQL, Python, Javascript/Typescript, Java etc.  
- Код-стайл - набор правил и соглашений, используемых при написании исходного кода на некотором языке программирования.  
- Язык программирования - формальный язык, предназначенный для записи компьютерных программ  
- Компиляция – трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду  


# Раздел 1. Описание предметной области
## 1.1 Особенности поддержки API в клиент-серверной архитектуре

> TODO: Расписать про клиент-серверную архитектуру - что это, особенности.

Несмотря на распространенность клиент-серверного подхода к проектированию систем, не существует общепринятого решения проблемы взаимодействия клиента и базы данных на сервере. Обрастая бизнес логикой, клиентская часть требует все более функционального интерфейса для получения данных - сущностей становится больше, с ложность фильтров повышается для минимизации потока передачи информации и нагрузки на передачу. Создаются ситуации, когда на клиенте нужно запросить какие-то данные, по определенным параметрам, но нужного API нет и все сводится к фильтрации на стороне клиента. Такая ситуация - результат ограничения, клиентская часть ограничена в функционале, она не может отправить оптимальный SQL запрос на сервер и получить нужные данные. Это обусловлено требованиями к безопасности - нельзя давать возможность присылать со стороны клиента произвольный SQL код. Если разрешить выполнять произвольный SQL-скрипт, то это создаст уязвимость системы, нарушение ее корректной работы, а также доступ к закрытым данным.

Из этого следует, что расширение бизнес логики ведет к увеличению количества методов в API. Это создается две проблемы - затруднение поддержки кодовой базы API и переусложненный процесс добавления функционала. Рассмотрим процесс добавления нового метода в типичную клиент-серверную архитектуру:
1. В условиях отсутствия ORM требуется добавить новую SQL-процедуру, которая реализует новую логику обращения к базе
2. Протаскивание вызова процедуры через слои абстракции сервера, добавление нового метода в API
3. Добавление логики обращения к новому методу API, его обработка 

## 1.2 Модель клиент-серверного взаимодействия в продукте Veeam Backup and Replication

> TODO: Распивать про инфраструктуру Veeam Cloud Provider. Источник: https://www.veeam.com/cloud-connect-backup-service-providers.html

Экосистема продуктов Veeam является одним из примером клиент-серверной архитектуры. Она предоставляет инструменты для реализации подхода Backup-as-a-Service. Клиент-серверное взаимодействие проявляется во работе двух основных компонентов:
- Veeam Backup and Replication - клиентское приложение, которое пользователи используют для работы с системой.
- Veeam Cloud Connect - ПО для сервис провайдеров, которые предоставляют BaaS услуги.

1. VBR поддерживает как бекапы в клауд, так и локальные. ИЗ-за этого в коде существует интерфейс обращения к данным и добавление каждого нового метода в алгоритмы сопровождается протаскиванием этого метода во все реализации.
2. Расширение бизнес-логики чревато очень резким увеличением кол-ва SQL-процедур. Это затрудняет поддержку и добавление поля в таблицу становится довольно затратным действием.
3. Система была заточена под MSSQL, но для дальнейшего развития требуется начать подготовку к переходу на разные базы данных, хотя бы на уровне отдельных компонент.


## 1.3 Функциональные и не функциональные требования

> TODO: Если утвердят внедрение PostgreSQL, то нужно добавить функциональное требование - возможность сменить базу с SQL Server на PostgreSQL

> TODO: Написать про UX - интерфейс модуля должен быть привычен пользователю, соотноситься с механизмом LINQ и Fluent interface.

Одним из решений проблемы описанной выше является создание механизма сериализации запроса на получение данных и реализация выполнения на удаленном узле. Иными словами, система должна уметь выражать запросы в виде сериализованного набора параметров.

Из этого следует функциональное требование - возможность унифицировать код для сценария, когда есть больше одного способа получения данных из базы, а именно:
- обращение к локальной базе на стороне клиента
- запрос на сервер с целью получить какие-то данные с внешней базы данных без дополнительной логики
- отправка запроса через прокси сервис - реализация возможности полученный запрос пробрасывать через несколько узлов.

Также, функциональным требованием является возможность модификации запроса на стороне сервера. Основная цель данного механизма - принудительно фильтровать только те данные, которые принадлежат клиенту, который запрос отправляет. Например, в случае если это база данных социальной сети, то запрос клиента на получение всех групп должен возвращать только те группы, которые открытые или к которым он имеет доступ.

Одной из проблем, которую должна решать данная система - навязывание строгой типизации при работе между C# и SQL. Обычно, если в проекте не используется ORM, то участки кода где передаются аргументы в запрос или читается ответ от сервера - являются потенциально багоопасными. Частые проблемы, которые нельзя выявить на этапе компиляции, только во время выполнения:
- аргумент в процедуру передается с неправильным именем. Довольно часто это может быть miss-spell или невнимательность ("objectId" и "object_id").
- нет проверки на то, какой тип ожидается как аргумент или какой тип вернулся в ответ на запрос.



Ввиду того, что внедрение подобного механизма при условии поддержания типизации в уже существующей системе - это процесс, которые занимает очень много времени, к списку требований добавлен пункт на автоматизацию внедрения. Автоматизация заключается в реализации кодогенерации всего нужного кода на основе уже существующей базы данных.

К нефункциональным требованиям можно отнести требование к безопасности. Это основная причина по которой использование готовых реализаций в виде ORM невозможен - результатом их работы является уже сформированный запрос, который нельзя передавать через API ввиду потенциальных SQL-инъекций.

## 1.4 Существующие решения

> TODO: Написать про GraphQL - частично решает схожую проблему, не подходит по стеку.

# Раздел 2. Архитектура библиотеки

## 2.1 Описание спецификации

Для реализации нового способа взаимодействия нужно ввести формат общения - спецификацию описания запроса в рамках модуля. Основные требования к спецификации:
- Должна концептуально быть схожа с SQL
- Должна уметь описывать основные элементы SQL запроса
- Должен поддерживать сериализацию и десериализацию

Проанализировав самые простые SQL-запросы, можно выделить элементы, которые должны быть отображены:
1. Описание таблицы на которую нацелен запрос. 
2. Условия фильтрации запросов, указанные с помощью ключевого слово WHERE: описание столбца по которому фильтр идет, оператор сравнения и значение, с которым нужно сравнить.
3. Список столбцов, которые нужно достать из базы для выполнения операции SELECT.
4. Поддержка механизма JOIN - перечисление пар таблиц, которые нужно соединить и соответствующие столбцы, которые будут использованы.  
5. Для операций UPDATE и INSERT нужно хранить список пар столбцов и их значений для выполнения соответствующего запроса.

Спецификацию для описания запросов можно представить использую формат описания типов json-schema

```JSON
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {
        "ColumnFullName": {
            "type": "object",
            "properties": {
                "Table": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                }
            },
        },
        "TypelessJoinDescriptor": {
            "type": "object",
            "properties": {
                "JoinedEntityTypeId": {
                    "type": "Guid"
                },
                "PrimaryEntityColumn": {
                    "type": "ColumnFullName"
                },
                "JoinedEntityColumn": {
                    "type": "ColumnFullName"
                }
            }
        },
        "TypelessWhereCondition": {
            "type": "object",
            "description": "Описание по котрому генерируется WHERE-условие, которое должно примениться к запросу",
            "properties": {
                "ColumnName": {
                    "type": "ColumnFullName"
                },
                "OperatorType": {
                    "type": "WhereOperatorType",
                    "description": "Нужно описать примитивный набор операторов сравнения: >, <, ="
                },
                "Value": {
                    "type": "object"
                },
                "ObjectType": {
                    "type": "Type"
                }
            }
        },
        "TypelessWhereConditionGroup": {
            "type": "object",
            "properties": {
                "Conditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TypelessWhereCondition"
                    }
                }
            }
        },
          "DatabaseUpdateArgument": {
            "type": "object",
            "properties": {
                "ColumnName": {
                    "type": "ColumnFullName",
                   
                },  
                 "ObjectType": {
                    "type": "Type",
                   
                },   
                 "Value": {
                    "type": "Object",
                   
                },               
            } 
        },
        "SelectQueryArgumentContainer": {
            "type": "object",
            "properties": {
                "JoinDescriptors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TypelessJoinDescriptor"
                    }
                },
                "Selectors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/ColumnFullName"
                    }
                },
                "WhereConditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TypelessWhereConditionGroup"
                    }
                },
                "OrderColumn": {
                    "type": "ColumnFullName"
                },
                "IsDistinct": {
                    "type": "Boolean"
                }
            } 
        },
        "UpdateQueryArgumentContainer": {
            "type": "object",
            "properties": {
                "UpdateArguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/DatabaseUpdateArgument"
                    } 
                    },
                     "WhereConditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TypelessWhereConditionGroup"
                    }
                    
                },              
            } 
        },
        "InsertQueryArgumentContainer": {
            "type": "object",
            "properties": {
                "UpdateArguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/DatabaseUpdateArgument"
                    } 
                },                          
            }
        },
        "DeleteQueryArgumentContainer": {
            "type": "object",
            "properties": {
                "WhereConditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TypelessWhereConditionGroup"
                    } 
                },                          
            }
        },
        "DatabaseQueryTask": {
            "type": "object",
            "properties": {
                "QueryType": {
                    "type": "QueryType"
                },
                "EntityTypeId": {
                    "type": "Guid"
                },
                "SelectArgumentContainer": {
                    "type": "SelectQueryArgumentContainer"
                },
                "UpdateArgumentContainer": {
                    "type": "UpdateQueryArgumentContainer"
                },
                "InsertArgumentContainer": {
                    "type": "InsertQueryArgumentContainer"
                },
                "DeleteArgumentContainer": {
                    "type": "DeleteQueryArgumentContainer"
                },
            }
        },
    }
}

```

## 2.2 Программная архитектура. Контрактно-ориентированное взаимодействие

Для эффективного взаимодействия с базой данных из кода требуется объекто описать все необходимые компоненты.

Самыми необходимым типами при работе с базой являются модели базы данных - классы, которые отображают в коде столбцы таблиц как переменные являясь дата-классами. Подобным функционалом, а именно - генерация дата-классов по схеме таблиц базы данных, обладает большинство современных ORM [@Троелсен, с. 843]. Помимо моделей, для таблицы должны быть введены дескрипторы - соответствующие классы, которые описывают:
- навзвание таблицы в SQL
- Идентификатор в системе
- Описание структуры таблицы - ее колонки
- Связи таблицы с другими таблицами - внешние ключи

> TODO: Дополнить - написать про дескрипторы таблиц 

Описаный слой абстракции решает проблему взаимодействия с базой, но он все еще не является орошим способом предоставить внешний интерфейс. Проблема состоит в том, что внешний пользователь работает не с таблицами, а с сущностями, которые могут быть сборными из разных таблиц.

Для реализации такой возможности нужно создать дополнительный слой абстракции - контракты. Контракт будет представлять собой обертку собранную из данных исходной базы, которая допустима в качестве DTO.
![](img/contract_deploy.png)

Определим основные сущности:
- Контракт - описание структуры определенной бизнес-сущности в системе, описание ее полей.
- Поле контракта - описание объекта, который является частью контракта. Это может быть как простое значение колоник из базы так и составное значение, которое собирается во время считывания с бд.
- Дескриптор контакта - аналог дескриптора таблицы, метаописание полей контракта, идентификатора.

Ключевым отличием от обычных оберток над таблицами являются поля контрактов. Их можно разделить на две категории:
- Простые. Это поля, которые мапятся 1 на 1 к определенному столбцу в базе. Стоит отметить, что контракт, скорее всего, будет состоять из полей, которые ссылаются на столбцы разных таблиц.
- Сложные. Покрывают сценарий, когда для получения какого-то значения нужно после считывания выполнять какую-то пост-обработку. например - подмена значения для совместимости со старым клиентом.
- Комплексные. Покрывают сценарий, когда для получения какого-то значения нужно вытаскивать несколько значений и их агреггировать.

<!-- > TODO: либо попроваить, либо выбросить
Процессинг таски с контрактом:
![](img/contract_activity.png) -->

Процесс обработки запроса контракта на стороне клиента 
![](img/contract_handling_sequence.png)


## 2.3. Схема размещения компонентов системы

Рассмотрим схему работы системы на транспортном уровне. В общем случае существует клиент, который отправляет спеку и сервер, который обрабатывает ее и возвращает ответ от базы данных.

![Deployment](img/Deployment.jpg)

Рассмотрим три сценария работы. Самый простой случай - работа с локальной базой. В этом кейсе запрос создается и выполняется на одной машине:
1. Формирование запроса
2. Генерация SQL-запроса, выполнение на локальной базе
3. Считывание ответа, формирование результата

![Activity, Client only](img/activity_client_only.png)

Более реальный кейс - это клиент-серверное общение:
1. Формирование запроса
2. Сериализация и отправка запроса на сервер
3. На стороне сервера происходит считывание запроса, выполнение нужных обработок, если нужно, и выполнение на базе, которая находится на стороне сервера
4. Считывание ответа от базы данных, формирование результата и отправка его на сторону клиента
5. Считывание ответа от сервера

![Activity, Client only](img/activity_client_server.png)

Последний кейс, которые заложен в архитектуру приложения - общение Клиент <-> Прокси <-> Сервер. Сценарий обработки не сильно усложняется:
1. Формирование запроса
2. Сериализация и отправка запроса на прокси
3. Прокси определяет, кто должен обработать данных запрос и отправляет соответствующему серверу.
4. На стороне сервера происходит считывание запроса, выполнение нужных обработок, если нужно, и выполнение на базе, которая находится на стороне сервера
5. Считывание ответа от базы данных, формирование результата и отправка его на сторону прокси
6. Прокси пробрасывает ответ клиенту
7. Обрабатываем полученный результат на стороне сервера

![Activity, Client only](img/activity_client_proxy_server.png)

## 2.4 Описание работы системы на стороне клиента

Рассмотрим использование и внедрение компонента в разных частях системы. Систему условно можно разделить на три важные  части - клиентская часть, прокси/гейтвей и серверная часть. Клиентская часть - это интерфейс взаимодействия программного решения пользователя с инструментами формирования запроса и механизмом его выполнения.

![Sequence  (client side)](img/Sequence&#32;(client&#32;side).jpg)

Конечной точкой отправки запроса всегда является база данных, для которой запрос нужно выполнить. Для взаимодействия с базой используется определенный обработчик запросов. Основная логика - создание SQL-запроса по спецификации обращения. Стоит отметить, что для разных баз данных нужно генерировать разные SQL-запросы т.к. синтаксис будет отличаться. Для прототипа была реализована SQL-генерация совместимая с SQL Server'ом. Алгоритм обработки спеки:
1. Получаем по id сущность, которую нужно подставить в **FROM**
2. Выполняем рекурсивный обход спеки и достаем все JOIN'ы и WHERE.
3. Собираем все колонки для SELECT
4. Отправляем запрос в базу
5. Считывает ответ и сериализуем его
В результате таких действий, по спеке можно получить результат выполнения и спарсить его на стороне клиента. 

Как было сказано ранее, есть несколько сценариев прохождения запроса. Они и определяют поведение между интерфейсом взаимодействия и таргетной базой:
1. Работа с локальной базой. В этом сценарии используется обработчик, который принимается спецификацию, обращается к своей базе, парсит ответ и возвращает его.
2. Работа с сервером. В данном сценарии подразумевается, что сформированный запрос используя нужный метод API сервера отправит его, и выполнятся он будет на серверной базе.
3. Использование гейтвеев или прокси. Расширение сценария клиент-серверного взаимодействия, которое предполагает наличие нод, которые буду проксировать обращения и результаты

<!-- TODO: ##  Описание работы системы на стороне сервера (на примере VCC) -->

## 2.5.  Интеграция с инфраструктурой Veeam Cloud Connect

Один из common cases для VBR - это бекапная джоба в клауд.

1. Взять информацию с локальной базы
2. Подключиться к провайдеру
3. Отправить данные, запустить на провайдере выполнение
4. Вытащить данные с клауда для синхронизации
5. Обновить информацию в базе
 
![Veeam-deploy](img/veeam-deployment.jpg)
 
- Veeam Backup Job Manager - бизнес логика которая покрывает в том числе выполнение бекапных джоб.
- Request builder - часть разработанного компонента, которая на клиентской стороне отвечает на построение запроса.
- TCP-client - часть клиентской логики, которая взаимодействует с провайдером.
- Cloud Gate - физический компонент экосистемы Veeam, который занимается проксированием запросов между клиентом и провайдером.
- TCP-handler - часть логики на стороне провайдера, которая отвечает за чтение TCP-запроса и запуск выполнения нужных команд.
- Request handler - часть разработанного компонента, которая на разбирает спецификацию и генерирует запрос к базе данных.
- Database - база данных со всей нужной информацией для выполнения бизнес-логики.

Одним из функциональных требований является возможность модифицировать на стороне сервера исходный запрос. В рамках VCC данный функционал необходим для того, чтобы гарантировать, что все запросы клиентов будут распространяться только на данные этого клиента и никакого другого:

1. Клиент подключается к серверу, устанавливается коннекция.
2. Клиент отправляет запрос к базе по средствам разработанного модуля
3. Сервер принимает запрос, по сессии смотрит идентификатор пользователя
4. Сервер изменяет запрос присоединяя нужную цепочку таблиц, чтобы по запрашиваемой сущности было понятно какому пользователю она принадлежит, добавляется условие WHERE по идентификатору пользователя
5. Выполняется запрос, возвращается результат.

## 2.6 Стек технологий

Ключевым аргументом при выборе стека является текущий стек разработки Veeam Backup and Replication посколько практическим применением результата данной работы является внедрение в существующее решение.  Он определен руководством на всем продукте, а поскольку весь продукт - это монолит, реализовать другие компоненты на другом стеке - довольн опроблематично.

Стек:
- Платформа .NET Framework 4.7.2, язык C# (version 7.3) 
- База данных SQL Server, T-SQL

Использованные библиотеки:
- Newtonjson - Библиотека для рабоыт с JSON для C#. Имеет весь нужный функционал для сериализации и десерилазации объектов в системе.
- TSQL_Parser - Библиотека, которая умееет разбивать SQL синтаксис на токены для дальнейшего анализа.
- Roslyn.CSharp.Scripting - Компоненты Roslyn, которые позволяют собирать синтаксическое дерево и генерировать C# код.
- nunit - Одна из самых распространенных баблиотек для написать unit-тестов 
- System.Data.SqlClient / System.Data.SQLite - библиотеки для работы с базами данными. SqlClient - библиотека для работы с базами данных SQL Server, SQLite - для работы с базой Sqlite, которая используется для unit-тестов.

# Раздел 3. Реализация

## 3.1 Инфраструктурные компоненты модуля

> TODO: Заменить примеры из AW на примеры из продукта

Рассмотрим объектно-ориентированное описание основных компонентов системы в коде. Базовым механизмом является работа с таблицами, а значит основными сущностями будет как раз таки дескрипторы таблицы и модели, которые получаются при обращении к таблице. В качестве примера взята таблица **таблица_нейм**. Ниже приведен скрипт ее создания:

```SQL
CREATE TABLE [Sales].[CreditCard](
	[CreditCardID] [int] IDENTITY(1,1) NOT NULL,
	[CardType] [nvarchar](50) NOT NULL,
	[CardNumber] [nvarchar](25) NOT NULL,
	[ExpMonth] [tinyint] NOT NULL,
	[ExpYear] [smallint] NOT NULL,
	[ModifiedDate] [datetime] NOT NULL,
 CONSTRAINT [PK_CreditCard_CreditCardID] PRIMARY KEY CLUSTERED 
(
	[CreditCardID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
```

> Написать что такое POCO

Данной таблице можно написать соответствующу модель POCO-класс:

```CSharp
public class CreditCardModel
{
    public Int32 CreditCardId { get; set; }
    public String CardType { get; set; }
    public String CardNumber { get; set; }
    public Int16 ExpMonth { get; set; }
    public Int16 ExpYear { get; set; }
    public DateTime ModifiedDate { get; set; }
}
```

> TODO: код устарел с момента последнего апдейта этой главы, нужно обновить.

Помимо самой модели для таблицы нужно еще описать дескриптор. Он описывает информацию про идентификатор таблицы, ее название:
```CSharp
Guid EntityId { get; } = Guid.Parse("13d9ed7c-76b8-435a-bf1e-790e16315ead");
TableDescriptor TableDescriptor { get; } = new TableDescriptor("[Production]", "ProductInventory");
(TypelessColumn, TypelessColumn) GenerateJoinRow(IEntityAccessor baseEntity);
DatabaseQueryTask ApplyFilter(DatabaseQueryTask queryTask);
IEnumerable<IColumn> GetColumns();
```

- EntityId - это идентификатор сущности, который используется в сериализаторе запроса чтобы не привязываться к названиям таблицы
- TableDescriptor - описание таблицы к которой привязан EntityAccessor: неймспейс и название
- GenerateJoinRow() - метод, который описывает возвращает пару столбцов по которым джоинятся таблицы

Также он описывает все столбцы, которые относятся к данной таблице:
```CSharp
public readonly Column<ProductInventoryAccessor, Int32> ProductId;
public readonly Column<ProductInventoryAccessor, Int16> LocationId;
public readonly Column<ProductInventoryAccessor, String> Shelf;
public readonly Column<ProductInventoryAccessor, Int16> Bin;
public readonly Column<ProductInventoryAccessor, Int16> Quantity;
public readonly Column<ProductInventoryAccessor, Guid> Rowguid;
public readonly Column<ProductInventoryAccessor, DateTime> ModifiedDate;

public ProductInventoryAccessor()
{
    ProductId = new Column<ProductInventoryAccessor, Int32>(TableDescriptor, "ProductId");
    LocationId = new Column<ProductInventoryAccessor, Int16>(TableDescriptor, "LocationId");
    Shelf = new Column<ProductInventoryAccessor, String>(TableDescriptor, "Shelf");
    Bin = new Column<ProductInventoryAccessor, Int16>(TableDescriptor, "Bin");
    Quantity = new Column<ProductInventoryAccessor, Int16>(TableDescriptor, "Quantity");
    Rowguid = new Column<ProductInventoryAccessor, Guid>(TableDescriptor, "Rowguid");
    ModifiedDate = new Column<ProductInventoryAccessor, DateTime>(TableDescriptor, "ModifiedDate");
}
```

Последнее свойство, которое должно быть отображено - это наличие связи с другими таблицами, существование внешнего ключа между ними. Чтобы обозначить такую связь на уровне типа в языке C# было принято решение использовать интерфейсы. Введена абстракция **IJoinable<T>**, имплементация которой показывает то, что текущий тип (дескриптор) является связаным с другим типом, типом **T**. Пример:

```CSharp
public class ProductInventoryAccessor : IJoinable<LocationAccessor>
{
    public (TypelessColumn, TypelessColumn) GenerateJoinRow(IEntityAccessor joinedEntityType)
    {
        switch (joinedEntityType)
        {
            case LocationAccessor _:
                return (SProduction.Location.LocationId, SProduction.ProductInventory.LocationId);
            default:
                throw new NotSupportedException(joinedEntityType.ToString());
        }
    }
}
``` 

Еще одним компонентом EntityAccesor'а является реализация интерфейса **IInsertDeconstructor<T>**, который имеет один метод **ConvertToColumn**, который разбирается дата-класс **T** на набор значений, которые нужно добавить с скрипт **Insert`:
```CSharp
public IEnumerable<DatabaseUpdateArgument> ConvertToColumn(ProductInventoryEntity value)
{
    yield return DatabaseUpdateArgument.Create(ProductId, value.ProductId);
    yield return DatabaseUpdateArgument.Create(LocationId, value.LocationId);
    yield return DatabaseUpdateArgument.Create(Shelf, value.Shelf);
    yield return DatabaseUpdateArgument.Create(Bin, value.Bin);
    yield return DatabaseUpdateArgument.Create(Quantity, value.Quantity);
    yield return DatabaseUpdateArgument.Create(Rowguid, value.Rowguid);
    yield return DatabaseUpdateArgument.Create(ModifiedDate, value.ModifiedDate);
}
```

> TODO: Модуль поддерживает работу с View. Можно привести примеры.


Ввиду того, что предполагается работа с уже существующей базой данных, реализована возможность работать также с уже написанными VIEW. С точки зрения SQL SELECT-запросов, обращения к ним не сильно отличаются от работы с таблицами, а значит есть возможность переиспользовать всю логику и не уточнять делается ли запрос к таблице или представлению.

## 3.2 Механизм построения запросов

> Эта часть очень сильно изменилась и описание примеров кода устарели полностью. Нужно продемонстрировать реализацию концепии Fluent interface при построении запросов

> TODO: расписать про имплементацию паттерна билдера, добавить примеры кода

Механизм создания запроса реализован в классе QueryTaskCreator, соответствует паттерну Builder. Builder - порождающий паттерн, отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. [@Тепляков, с. 160]

<!-- Он содержит набор методов для добавления какой-то информации в спеку:
- From - создает новую команду принимая на вход `EntityAccessor`
> Вот тут с дескриптором что-то такое себе

- `Where<TFieldValue>(WhereCondition<T1, TFieldValue> whereCondition)` - добавляет новое условие для `WHERE`-команды, принимает на вход дескриптор для данного `EntityAccessor`
- `Join<T2>(T2 joinedEntity)` - добавляет информацию о том, что нужно выполнить `JOIN` с таблицей чей `EntityAccessor` был передан в качестве аргумента. На этапе компиляции выполняется проверка, что `joinedEntity` реализует `IJoinable<>` для нужного `EntityAccessor`
- `Select(IEntitySelector selector)` - метод, который принимает описание столбцов, по которым будет делаться выборка для получения определенной сущности базы данных 

По итогу получаем функциональность генерации описанной выше спеки с проверкой типов и уменьшением количества потенциальных багов. -->



## 3.3 Генерация SQL-запросов по разработанной спецификации

Для реализации возможность описывать функицонал SQL-запросов ввиде самописной спецификации, нужно выделить основные типы запросов:
- SELECT
- INSERT
- UPDATE
- DELETE

> TODO: Обновить информацию в этой схеме, поля могли измениться

> TODO: написать, что такое json-schema



Для работы с этой спецификацией описаны соответствующие объекто-ориентированные описания элементов спецификации.

> TODO: более детально расписать про соответствие полей классов и сгенерированного SQL

Данные для SELECT-запроса строятся по спеке:
```CSharp
public class ResolvedSelectQueryArgumentContainer
{
    public IEntityDescriptor EntityDescriptor { get; set; }
    public List<ResolvedJoinDescriptor> JoinDescriptors { get; set; }
    public List<IColumn> Selectors { get; set; }
    public List<ResolvedWhereConditionGroup> WhereConditions { get; set; }
    public IColumn OrderColumn { get; set; }
    public Boolean IsDistinct { get; set; }
}
```

и разворачиваются в
```SQL
SELECT
    [DISTINCT]
    <selectors list>
FROM
    <entity descriptor>
    JOIN <joinDescriptor table name>
        ON <column for join>
WHERE
    <where conditions>
ORDER BY <order column>
```

Данные INSERT-запроса строятся по спеке:
```CSharp
public class ResolvedSelectQueryArgumentContainer
{
    public IEntityDescriptor EntityDescriptor { get; set; }
    public List<ResolvedDatabaseUpdateArgument> UpdateArguments { get; set; }
}
```
и разворачиваются в
```SQL
INSERT INTO <entity descriptor> (<fields>)
VALUES (<values>)
```

Данные UPDATE-запроса строятся по спеке:
```C#
public class ResolvedSelectQueryArgumentContainer
{
    public IEntityDescriptor EntityDescriptor { get; set; }
    public List<ResolvedDatabaseUpdateArgument> UpdateArguments { get; set; }
    public List<ResolvedWhereConditionGroup> WhereConditions { get; set; }
}
```
и разворачиваются в
```SQL
UPDATE <entity descriptor>
SET
    <values>
WHERE
    <conditions>
```

Данные DELETE-запроса строятся по спеке:
```C#
public class ResolvedSelectQueryArgumentContainer
{
    public IEntityDescriptor EntityDescriptor { get; set; }
    public List<ResolvedWhereConditionGroup> WhereConditions { get; set; }
}
```
и разворачиваются в
```SQL
DELETE <entity descriptor>
WHERE
    <conditions>
```

Алгоритм построения запросов является довольно очевидным. Более того, он не зависит от остальных компонентов системы, а просто строится на основании переданных параметров. Из этого можно сделать вывод, что при желании можно реализовать подобный генератор запросов не только для SQL Server, а и для других диалектов SQL.


# Раздел 4. Кодогенерация инфраструктуры

## 4.1 Roslyn

> TODO: Добавить информацию о том, что из Roslyn используются компоненты для кодогенерации

Roslyn - компилятор исходного кода .NET, который предоставляется как CaaP (Compiler-as-a-Platform). Является проектом Microsoft с открытым исходным кодом. Поддерживаемыми  языками являются C# и VB, который используют .NET в качестве среды выполнения. Основная идея проекта Roslyn заключается в раскрытии процесса компиляции, предоставление доступа пользователям к взаимодействию с различными его этапами.
Гибкость в плане расширений и возможность кастомизации дают возможность применять данный инструмент в качестве внешнего анализатора кода.

Архитектура Roslyn'а имеет ряд особенностей, которые объясняются набором функционал, который данное продукт реализует. В первую очередь, данное средство автоматизации является компилятором и именно логика процессов компиляции лежит в основании всей системы. Остальные компоненты являются функциональными расширениями процесса компиляции и являются зависимыми от компоненты "Compilers". Не смотря на то, что другие компонент группируются на основе какой-то функционала, они взаимодействуют между собой, переиспользуют структуры данных других модулей, используют их  зависимости и расширяют их. Этим обусловлена сильная связанность между ними. На диаграмме представлена модель системы, где элементами являются именно эти компоненты.

Раскрытие «черного ящика» компиляторов дает широкий ряд возможностей для улучшения условий работы с кодом. Программный компонент Roslyn, который является платформой предоставляющей функционал компилятора, как раз таки нацелена на интеграцию этих процессов, их управление и использование в процессе разработки. Часть этих компонент предоставляются как библиотеки для проектов с целью их расширения и имплементации на их основе нового функционала.
При анализе было отмечено, что программный компонент представляется на разных уровнях абстракции – с ним можно интегрироваться как на уровне добавления правил код-стайла, так и внедрить дополнительную логику разбора исходного кода.
Обобщив информацию полученную в ходе работы над Roslyn, можно прийти к заключению, что это современный инструмент, который значительно может упростить работы как с анализом кода, так и его написанием (например, кодогенерацией), а также дает возможность пользователям разрабатывать инструменты, которые решают непосредственно их задачу и настраивать уже существующие под себя.


## 4.2. Применение кодогенерации

Одним из нефункциональным требованием является кодогенерация нужных для использования Fluda компонентов. Довольно тривиальной проблемой при работе с базой данных является то, что табличные сущности (модели) нужно описывать дважды: в виде SQL-кода создания таблиц и на языке, который используется для бекенда, логика парсинга ответа от базы данных. Обычно, имеется два подхода.
Code first - подход, который заключается в том, чтобы описывать сущности на языке бекенда, а потом использовать различные инструменты для создания базы данных на их основе. Самым популярной реализацией данного подхода в .NET-стеке является EntityFramework. Это библиотека в которой реализовано много функционала для работы с базой данной и один из них - это как раз генерация SQL-запросов для создание таблиц на основании написанных классов-моделей. 

Противопоставить можно другой подход - Db first. Он заключается в том, что сначала описывается база данных, таблицы, а потом генерируются шаблонные модели. В отличии от Code first такой подход можно применить к уже готовой базе, которая ранее использовалась без ORM. Он подразумевает анализ схемы базы данных, выделение ее элементов и генерации соответствующих классов. 

Ввиду того, что основной задачей данного компонента является реализация нового подхода, замена существующего функционала бекенда, ориентиром является именно существующая база, которая не будет изменятся.

## 4.3. Использование SQL-скрипта для анализа схемы базы

> TODO: Написать про SQL особенности генерации запросов. Пояснить, почему это только для Sql Server и почему прикрутить что-то другое - не сложно.

Основой для кодогенерации является база данных, ее схема. Если точнее - информация о том, какие есть сущности, что они из себя представляют (список столбцов) и какие между ними связи. Разные СУБД баз данных используют разный синтаксис для описания, минорные отличия в SQL. Рассмотрим самый популярные из них:
- MS SQL
- SQLite
- MySql
- PostgreSql

> TODO: Расписать про различия в синтаксисе MS SQL / SQLite / PostgreSQL

Входе сравнения выяснили, что отличия хоть и есть, но являются минорными и взаимозаменяемыи. Но ввиду того, что Sql Server является самым распространенной СУБД, именно он будет использоваться как основной. Дополнительно стоит рассмотреть и поддержать синтаксис SQLite т.к. это самый простой способ проверять в дальнейшем работу CSDA.

Рассмотрим основные SQL-конструкции, которые будут использованы для кодогенерации.
Рассмотрим возможные виды команд в SQL-скрипте создания запроса для Sql Server'а. Используя SSMS можно сгененрировать скрипт, где будет описание нужных сущностей бд:
- CREATE TABLE
- CREATE VIEW
- FOREIGN KEY
- Другое

> TODO: расписать про библиотеку TSQL.Parse 


В первую очередь выполняется парсинг SQL скрипта создания базы для Sql Server. Выполняется парсинг на токены с помощью библиотеки TSQL.Parse. После этого выполняется деление на отдельные запросы по ключевому слову GO. Каждый запрос классифицируем в одну из категорий:

Типичный запрос на создание таблицы состоит из:
- **CREATE TABLE [_1_].[_2_]**, где _1_ - это схема, а _2_ - это название таблицы, которое должно быть использовано как название сущностей/моделей
- Список описаний столбцов формата **[ModifiedDate] [datetime] NOT NULL**, где **ModifiedDate** - название столбца, которое должно соответствовать названиям полей класса, **[datetime]** - тип поля, которое должно быть переведено в тип используемого ЯП, **NOT NULL** - указание того, может ли поле не иметь значение, что соответственно должно отобразиться на полях моделей.
- **CONSTRAINT [PK_Person_BusinessEntityID] PRIMARY KEY** - описание ключей, которое не влияет никак на модели и кодогенерацию.

**View** по результату парсинга должны выглядеть также, как и таблицы, хотя имеет совершенно другую структуру:
- **SELECT ...** - перечисление столбцов, которые будут в представлении.
- **FROM table_name** - список таблиц, из которых выбираются столбцы
- **JOIN** - список таблиц, которые джойнятся также для получения столбцов.


<!-- > TODO: Расписать про муки и страдания с парсингом и почему это не очень решение -->


Основная проблема с представлениями - в них явно не указываются типы, а значит, для каждого столбца нужно смапить таблицу с которой он взят и по ней определять тип.

Также, к схеме базы можно отнести **Foreign key** - их можно воспринимать как описание связей между двумя таблицами, явное указание, что эти таблицы можно джоинить. Шаблон такого скрипта:
- **ALTER TABLE [Sales].[SalesPerson]** - указание одной из таблиц, котороя будет джоиниться
- **WITH CHECK ADD  CONSTRAINT [FK_SalesPerson_SalesTerritory_TerritoryID]** - SQL-синтаксис для указания, что это FK, не имеет смысловой нагрузки в данном контексте.
- **FOREIGN KEY([TerritoryID])** - указание столбца первой таблицы, который используется для джоина
- **REFERENCES [Sales].[SalesTerritory] ([TerritoryID])** - указание второй таблицы и ее столбца для джоина

<!-- > Расписать про парсинг -->

## 4.4 Использование метаинформация про базу данных для анализа схемы

Помимо парсинга скрипта создания базы есть другой спосой ознакомится с ее структурой. База данных в Sql server содержит ряд служебных таблиц в которых лежит описание разлиных объектов.

> TODO: Почитать у Виейра "Программирование баз данных Microsoft SQL Server" про sys.Object, расписать подробно

> TODO: Расписать детально как происходит испольхование этой информации для кодогенерации

Используя запрос
```SQL
SELECT
	s.name as TableScheme,
	o.name AS TableName,
	type,
	c.name AS ColumnName,
	t.name AS DataType,
	c.is_nullable AS IsNullable
FROM sys.objects AS o
INNER JOIN sys.columns AS c ON o.object_id = c.object_id
INNER JOIN sys.types AS t ON c.user_type_id = t.user_type_id
INNER JOIN sys.schemas AS s ON o.schema_id = s.schema_id
WHERE type = 'U' OR type = 'V'
```

можно получить информацию о существующих таблицах и предславлениях, их столбцах. Помимо этого, в базе также можно найти инфрмацию о ключах:
```SQL
SELECT  obj.name AS FK_NAME,
    sch.name AS [schema_name],
    tab1.name AS [table],
    col1.name AS [column],
    tab2.name AS [referenced_table],
    col2.name AS [referenced_column],
    sch2.name AS [referenced_schema_name]
FROM sys.foreign_key_columns fkc
INNER JOIN sys.objects obj
    ON obj.object_id = fkc.constraint_object_id
INNER JOIN sys.tables tab1
    ON tab1.object_id = fkc.parent_object_id
INNER JOIN sys.schemas sch
    ON tab1.schema_id = sch.schema_id
INNER JOIN sys.columns col1
    ON col1.column_id = parent_column_id AND col1.object_id = tab1.object_id
INNER JOIN sys.tables tab2
    ON tab2.object_id = fkc.referenced_object_id
INNER JOIN sys.columns col2
    ON col2.column_id = referenced_column_id AND col2.object_id = tab2.object_id
INNER JOIN sys.schemas sch2
    ON tab2.schema_id = sch2.schema_id
```

## 4.5 Кодогенерация инфраструктурных компонент

Поскольку все сущности, столбцы и связи между ними имеют зависимость от базы, было решено реализовать кодогенерацию их описания по SQL-скрипту создания базы, который можно вытащить из существующей.

Рассмотрим генерация основных элементов системы:
1. Entity
2. EntityAccessor (Table/View)
3. Схема
4. Конвертор

Рассмотрим генерацию моделей (Entity). Чтобы представить результат полученный с базы в C#-коде - его нужно спарсить в экземпляр какого-то класса. А значит для каждой таблицы нужно сгенерировать соответствующие дата-классы в которые будут читаться данные. Поля класса заполняются на основании названий столбцов таблицы и их типа:
```CSharp
using System;

namespace AdventureWorkSample.Models
{
    public class ProductInventoryEntity
    {
        public Int32 ProductId { get; set; }
        public Int16 LocationId { get; set; }
        public String Shelf { get; set; }
        public Int16 Bin { get; set; }
        public Int16 Quantity { get; set; }
        public Guid Rowguid { get; set; }
        public DateTime ModifiedDate { get; set; }
    }
}
```

Можно выделить основные элементы этого кода:
- директива подклбчения пространства имен где описаны все примитивные типы
- Объявление пространства в котором находится класс
- Объявление класса
- Объеявление свойства.

Этапы генерации:
1. Сгенерировать свойство для каждого столбца таблицы. Имея описание стоблца и используя Roslyn (Microsoft.CodeAnalysis.CSharp) можно сгенерировать с помощью кода:
```CSharp
PropertyDeclaration(TypeParsers.Parse(columnDescriptor), columnDescriptor.ColumnNameForField())
    .AddModifiers(Token(SyntaxKind.PublicKeyword))
    .AddAccessorListAccessors(
        AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken)),
        AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken)));
```


# Литература

1. Прайс - CSharp 7 и Net Core. Кроссплатформенная разработка [ПР]
2. Троелсен - Язык программирования C# 7 и платформа .NET
3. Виейра Р. Программирование баз данных Microsoft SQL Server 2005. Базовый курс (2007)
4. Тепляков - Паттерны_проектирования_на_платформе_NET