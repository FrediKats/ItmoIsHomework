<!--Перед тем, как вы захотите совершить суецид, попробуйте посмотреть (сюда можно добавить что-то свое):
1. Лекция по git'у от Яндекса: https://youtu.be/yDSs80lu3ak
2. Запись выступления о git'е с DotNetRu: https://youtu.be/8nts8C209W0
3. Что такое bare-репозиторий: http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/ (у него нет рабочего дерева, предназначен он исключительно для хранения/шейринга)
4. Скрин-описание ключа interactive лежит в папка
5. Не забудь спросить у Липкина за GPG (хоба - и это уже TODO-list. Не ждали? Я сам в шоке)
6. А еще shallow
-->

# Create, setup, config

- Общие ключи
    - `-q/-quite` - вывод только ошибок и предупреждений, игнорируя остальную информацию
    - `-v/--verbose` - вывод более детальной информации
    - `-z`/`--null` - заканчивать вывод информации NUL-чаром вместо переноса строки

- [x] [config](https://git-scm.com/docs/git-config) - конфигурация гита (имя пользователя, текстовый редактор)
    - Действия
        - --replace-all (замена всех переменных, подходящих под данную регулярку)
        - --add (добавляет строку настройки без изменения уже существующих настроек)
        - --get (получение значения по ключу)
        - --get-all (получение всех пар ключ-значение по регулярке)
        - --get-regexp / --get-urlmatch (фильтр по регуляркам/ url)
        - --unset --unset-all (удалить переменную / все переменные, подходящие под данную регулярку)
        - --rename-section / --remove-section (переименование/удаление секции)
        - --list (показать все настройки)
        - -l/--list (список всех настроек в конфиг-файле)
        - -e/--edit (открывает редактор для редактирования конфиг-файла)
    - Ключ для установки настроек
        - --global (установка настроек для пользователя, файл ~/.gitconfig)
        - --system (установка настроек системы, файл /etc/.gitconfig)
        - --local (установка настроек в локальном репозитории)
        - --blob < blob-id > (чтение настроек из данного бинарного файла)
    - Другое
    - --name-only (вывод только названий переменных из конфига для команд --list)
    - --show-origin (показывает путь до места, где был объявлена переменная)
    
- [x] [init](https://git-scm.com/docs/git-init) - создание пустого git-репозитория
    - `--bare` - создание bare-репозитория
    - `--template=<template_directory>` - директория с которой будут скопированы файлы перед клонированием
    - `--separate-git-dir=<git dir>` - указание пути для папки `.git/`. По-умолчанию создается в корне репозитория.


- [x] [clone](https://git-scm.com/docs/git-clone) - клонирование репозитория в новую папку
    - `-l/-local` - клонирование локального репозитория
    - `--no-hardlinks` - копирование всех объектов репозитория, без использования hard-link
    - `-s`/`--shared` - использовать ссылки на родительский репозиторий
    - `--reference <repository>` - использовать ссылки на другой локальный репозиторий вместо клонирования
    - `--progress` - выводить прогресс в stderr
    - `-n/--no-checkout` - не выполнять команду checkout по завершению клонирования
    - `--bare` -  создание bare-репозитория
    - `-o/--origin <name>` - указание имя для внешней ссылки. По-умолчанию - это origin
    - `-b/--branch` - указать ветку на которую будет ссылаться HEAD. По-умолчанию делает такой же, как и в клонируемом репозитрие
    - `--template=<template_directory>` - директория с которой будут скопированы файлы перед клонированием
    - `-c/--config <key>=<value>` - добавление параметров в созданный репозиторий
    - `--[no-]single-branch` - клонирование изменений только одной ветки, дальнейшие фетчи будут выполняться также только для нее
    - `--no-tags` - не клонировать тэги
    - `--recurse-submodules` - рекурсивная инициализация и клонирование сабмодулей
    - `--separate-git-dir=<git dir>` - указание пути для папки `.git/`. По-умолчанию создается в корне репозитория.
    - `-j/--jobs` - максимальное количество модулей, которые могут фетчиться одновременно
    - `--dissociate` (позволяет отделить репозиторий, склонированный через --reference)

# Snapshot
- [x] [add](https://git-scm.com/docs/git-add) - добавление файлов в индекс
    - `-n`/`--dry-run` - не добавлять файлы, вывести информацию о том, существуют ли они и будут ли проигнорированы
    - `-f`/`--force` - разрешает добавление игнорируемых файлов
    - `-i`/`--interactive` (смотреть пикчу(!); интерактивно добавить модифицированный контент в рабочее дерево к индексу)
    - `--patch` - интерактивный выбор частей патча между индексом и рабочим деревом, добавление их в индекс
    - `--edit` - открывает diff с индексом в редакторе и дает пользователю отредактировать его
    - `--update` - обновляет сущности, которые уже в индексе или удаляет их, но не добавляет новые
    - `-A`/`--all`/`--no-ignore-removal` - добавить изменение всех индексируемых и не индексируемых файлов
    - `--no-all`/`--ignore-removal` - добавить изменение всех индексируемых, но игнорировать удалённые из индекса файлы
    - `--refresh` - не добавляет файлы, только обновляет информацию в индексе
    - `--ignore-errors` - игнорировать ошибки при добавлении и продолжать добавлять
    - `--no-warn-embedded-repo` - отключить уведомление о том добавлен подрепозиторий, который не является сабмодулем
    - `--renormalize` - удалить и добавить все файлы индекс
    
- [x] [status](https://git-scm.com/docs/git-status) - показывает статус рабочего дерева и состояния файлов
    - `-s`/`--short` - вывод в коротком формате
    - `-b`/`--branch` - отобразить информацию о ветке игнорирую `-s`
    - `--show-stash` - отобразить кол-во элементов в стеше
    - `--long` - вывод всех инофрмации. По-умолчанию
    - `-u <mode>`/`--untracked-files[=<mode>]` - вывод не затреканых файлов
        - no - не отображать
        - normal - отображать незатреканные файл и директории
        - all - отображать также файлы в незатреканных директориях
    - `--ignore-submodules[=<when>]` - игнорировать изменения в сабмодулях
    - `--ignored[=<mode>]` - отображать файлы с игнор листа
        - traditional - отображать игнорируемые файлы и папки
        - no - отображать не игнорируемые файлы
        - matching - отображать по маске
    - `--[no-]renames` - использует/не использует трекинг переименований

- [x] [diff](https://git-scm.com/docs/git-diff) - показывает разницу между коммитами/ветками
    - `-p`/`-u`/`--patch` - генерирует патч 
    - `-s`/`--no-patch` - не выводить патч
    - `-u <n>`/`--unified=<n>` - показывает diff с n-ым кол-вом строк 
    - `--raw` - вывод diff в формате plain text
    - `--minimal` - более долги анализ для генерации минимально возможного diff
    - `--diff-algorithm={patience|minimal|histogram|myers}` - нужный алгоритм для генерации diff
    - `--stat` - показывает список файлов с изменениями
    - `--summary` - вывод расширенной информации о файле вроде создания, переименования или изменения прав на доступ
    - `-z` - использование NUL в качестве терминатора
    - `--name-only` - отображать только название измененных файлов
    - `--name-status` - отображать только имя и статус измененных файлов
    - `--submodule[=<format>]` - формат вывода для сабмодулей
    - `--no-renames` - отключить поиск переименнованных файлов
    - `--check` - показывает, существуют ли конфликтующие пробелы
    - `-M`/`--find-renames` / `-C`/`--find-copies` - позволяет выявлять переименования файлов или копии
    - `-a`/`--text` - обработать все файлы как текст
    - `-b`/`--ignore-space-change` - игнорировать изменения пробелов в конце строки
    - --cached / --staged - вывод diff между коммитом и заиндексированным состоянием(git add)
    - --no-index - позволяет сравнить неиндексируемые файлы

- [x] commit (создание коммита т.е. фиксация некого состояние репозитория)
    - -a/--all (автоматически застейджить все файлы, которые были изменены или удалены)
    - -p/--patch (использовать интерфейс патча для просмотра изменений для коммита)
    - --interactive (выводит возможные дополнительные опции перед коммитом)
    - -c/--reedit-message=< commit > (изменить сообщение коммита)
    - --fixup=< commit > (создаёт сообщение к коммиту с префиксом fixup для rebase --autosquash)
    - --squash=< commit >  (создаёт сообщение к коммиту с префиксом squash для rebase --autosquash)
    - --reset-author -при изменение коммита меняется автор на того, кто менял коммит
    - --short (для dry-run вывод в кратком формате)
    - --branch (выводить информацию о ветках даже в --short)
    - --long (для dry-run вывод полной информации)
    - -F < file >/--file=< file > (взять сообщение коммита из файла)
    - --author=< author > (указать автора)
    - --date=< date > (указать дату коммита)
    - -m < msg >/--message < msg > (указание сообщение коммита)
    - --no-verify / --no-post-rewrite (обход прекоммитных/ посткоммитных хуков)
    - --allow-empty (возможность создания пустого коммита)
    - --allow-empty-message (разрешает коммиты без сообщений)
    - -e/--edit (позволяет изменить сообщение, которое получено с -F/-m/-C)
    - --no-edit (не открывать редактор сообщения коммита)
    - --amend (отмена предыдущего коммита, создание нового на основании сделанного и новых изменений)
    - -o/--only (коммитить только указанный файл)
    - -u[< mode >]/--untracked-files[=< mode >] (отображать не заиндексированные файлы)
        - no (не отображать)
        - normal (отображать не затреканные файлы и папки)
        - all (отображать также файлы в незатреканных папках) (дефолтное значение)
    - `--dry-run` - показать файлы, которые будут добавлены в коммит
    - --[no-]status (выводит/ не выводит статус как в git status)

- [x] [reset](https://git-scm.com/docs/git-reset) - перемещение head, индекса и рабочего дерева до указанного коммита в зависимости от режма
    - режимы reset:
        - `--soft` - сбросить только HEAD
        - --mixed - сбросить HEAD и индекс
        - `--hard` -  сбросить HEAD и индекс и рабочее дерево
        - --keep -  сбросить HEAD, но сохранить изменения локально
    - -p, --patch - использует интерфейс патча
    
- [x] [rm](https://git-scm.com/docs/git-rm) - удаление файла из рабочего дерева и индекса
    - --force - позволяет удалять индексированные файлы с незакоммиченными изменениями
    - `--dry-run` - не удалять файлы, вывести информацию о том, существуют ли они в индексе и были бы ли они удалены
    - `-r` - разрешает рекурсивное удаление, если указано название папки
    - --cached - удалить только из индекса

- [x] rebase (перемещение коммитов из ветки на последний коммит другой ветки)
    - --onto < branchname > (ветка, на которую перемещаем)
    - --autostash - сохраняет состояние рабочего дерева перед rebase
    - --fork-point - ищет наилучшего предка для веток
    - -r, --rebase-merges  - попытка пересоздать слияния после rebase, чтобы сохранить структуру дерева
    - -p, --preserve-merges - попытка сохранить структуру дерева со слияниями
    - --no-ff, -f, --force-rebase - перемещение коммитов по одному, сохраняя историю коммитов
    -  -i, --interactive (возможность переписывать коммиты для rebase)
    -  --allow-empty-message (позволяет пустые сообщения)
    - --stat/ --no-stat - показывать/ не показывать diff
    - --verify( разрешает прекоммитные хуки)
    -  --autosquash (перемещает коммиты которые начинаются на squash!/ fixup! под -i для слияния)
    - Действия
        - --continue - продолжить
        - --abort - прервать
        - --skip - пропустить патч и продолжить
        - --edit-todo - изменить todo-лист во время интерактивного rebase
        -  --quit - выйти, но оставить HEAD там, где он остался
        - --show-current-patch - показать текущий патч


# Branches
- [x] branch (выполнение различных операций с ветками)
    - -a, --all (выводит список всех локальных и удалённых-индексируемых веток)
    - -d/--delete (удалить смёрженную ветку)
    - -D (удалить ветку, даже если не было merge)
    - -m, --move - перемещает/переименовывает ветку
    - --list (вывести список названий веток)
    - --create-reflog - создаёт историю перемещения HEAD для ветки
    - -f, --force - игнорировать конфликты создания/переименования/удаления
    - `--merged/--no-merged <commit> ` - вывести только слитые/неслитые ветки

- [ ] checkout (создание ветки и установка HEAD на неё)
    - --force (выбрасывает изменения и выполняет переход)
    - --ours/ --theirs
    - -b < new_branch > (создание новой ветки)
    - -t/--track
    - -l - создание истории изменения HEAD
    - --detach
    - --merge
    - --conflict=< style >
    - -p/--patch
    - --ignore-other-worktrees
    - --[no-]recurse-submodules
    -  --overwrite-ignore

- [x] [merge](https://git-scm.com/docs/git-merge) - слияние веток (историй разработки)
    - `--[no-]commit` - установка флага, нужно ли комитить изменения после вынужденного мерджа при пуле.
    - `-e`/`--[no-]edit` - открыть редактор до комита после мерджа
    - --`[no-]ff` - если можно резолвить конфликт fast-forward'ом, то обновляет указатель на ветку не создавая мердж-комита
    - `--ff-only` - создавать мердж-комит, даже если можно резолвить fast-forward'ом
    - [ ] `--log[=<n>]`/`-no-log` - 
    - [ ] --[no-]signoff
    - `-n`/`--[no-]stat` - выводить diff-статистику в конце мерджа. `-n` = `--no-stat`
    - `--[no-]squash` - сквошить комиты один вместо мерджа
    - [ ] --allow-unrelated-histories
    - `-r/--[no-]rebase[=false|true|merges|preserve|interactive]` - после fetch выполняется rebase на последний комит с upstream'а. <!--возможно, строит описать более детально-->
    - `--[no-]autostash` - если указан `--rebase`, то изменения будут стешится перед выполнением rebase'а
    - `-m <msg>` - сообщение для комита, что будет создан при мердже
    - `-F <path>`, `--file=<path>` - файл, с которого будет считано сообщение для комита
    - `--abort` - абортнуть текущий резолвинг конфликта и попытаться вернуть состояние до мерджа  
    - `--continue` - продолжить операцию мерджа
    - `--progress` - выводить прогресса в stderr

- [ ] stash сохранение изменений локально без комита
    - list [<options>]
    - show [<stash>]
    - drop [-q|--quiet] [<stash>]
    - branch <branchname> [<stash>]
    - push
    - clear

- [x] [tag](https://git-scm.com/docs/git-tag) (создание, удаление и проверка тега объекта)
    - `-a`/`--annotate` - создаёт аннотированный объект без подписи
    - `-f`/`--force` - заменяет существующий тег на указанное имя (вместо отказа)
    - `-d`/`--delete` - удаление тегов с указанными именами
    - `-l`/`--list <pattern>` - вывод тегов по шаблону 
    - `-n<num>` - указывает, сколько строк из аннотации, если они есть, печатаются при использовании -l
    - `--sort=<key>` - сортировка на основе заданного ключа
    - `-i`/`--ignore-case` - игнорирование регистра при сортровке и фильтрации
    - `[--no-]contains [<commit>]` - выбрать только те ветки, которые содержат (не содержат) указанный комит
    - [ ] `--[no-]merged [<commit>]` - выбрать только те комиты, которые достижимы с указанного <!--Не очень понятно-->
    - `--points-at <object>` - выбрать теги, которые ссылаются на данный объект
    -  `-m <msg>`/`--message=<msg>` - сообщение для тега
    - `-F <file>`/`--file=<file>` - указание файла, с которого будет взят текст для сообщения
    - `-e`/`--edit` - открыть редактор перед созданием тега для редактирования сообщения

# Sharing
- [ ] [fetch](https://git-scm.com/docs/git-fetch) - скачивание объектов и ссылок из другого репозитория
    - `--all` - получить все данные с удалённого репозитория
    - `-a`/`--append` - добавление **ref names and object names** в `.git/FETCH_HEAD`. Без этого **атрибута** данные в этом файле будут перезаписаны
    - `--depth=<depth>` - ограничение на кол-во комитов, которые будут скачены с каждой ветки
    - `--dry-run` - показывает, что будет сделано, без выполнения команды
    - [ ] -f/--force
    - `-p`/`--prune` - перед fetch удаляет ссылки на несуществующие объекты на удаленном репозиторие
    - `-P`/`--prune-tags` - перед fetch удаляет  все локальные теги, которые больше не существуют на удаленном репозитории
    - `-n`/`--no-tags` - отключает автоматический fetch тегов
    - `-t`/`--tags` - fetch всех тегов из удаленного репозитория
    - `--recurse-submodules[=yes|on-demand|no]` - выполнять ли fetch для всех сабмодулей
    - `-j`/`--jobs=<n>` - максимально число fetch'ей, которые могут выполняться одновременно
    - `--progress` - выводить прогресса в stderr


- [ ] [pull](https://git-scm.com/docs/git-pull) - выполнение fetch и интеграция с другим репозиторием или локальной веткой
    - `--recurse-submodules[=yes|on-demand|no]` - выполнять ли fetch для всех сабмодулей
    - Опции, связанные с **merge**
        - `--[no-]commit` - установка флага, нужно ли комитить изменения после вынужденного мерджа при пуле.
        - `-e`/`--[no-]edit` - открыть редактор до комита после мерджа
        - --`[no-]ff` - если можно резолвить конфликт fast-forward'ом, то обновляет указатель на ветку не создавая мердж-комита
        - `--ff-only` - создавать мердж-комит, даже если можно резолвить fast-forward'ом
        - [ ] `--log[=<n>]`/`-no-log` - 
        - [ ] --[no-]signoff
        - `-n`/`--[no-]stat` - выводить diff-статистику в конце мерджа. `-n` = `--no-stat`
        - `--[no-]squash` - сквошить комиты один вместо мерджа
        - [ ] --allow-unrelated-histories
        - `-r/--[no-]rebase[=false|true|merges|preserve|interactive]` - после fetch выполняется rebase на последний комит с upstream'а. <!--возможно, строит описать более детально-->
        - `--[no-]autostash` - если указан `--rebase`, то изменения будут стешится перед выполнением rebase'а
    - Опции, связанные с **fetch** <!--Проверить все-->
        - `--all` - получить все данные с удалённого репозитория
        - `-a`/`--append` - добавление **ref names and object names** в `.git/FETCH_HEAD`. Без этого **атрибута** данные в этом файле будут перезаписаны
        - `--depth=<depth>` - ограничение на кол-во комитов, которые будут скачены с каждой ветки
        - [ ] -f/--force
        - `-n`/`--no-tags` - отключает автоматический fetch тегов
        -  `--progress` - выводить прогресса в stderr

- [ ] [push](https://git-scm.com/docs/git-push) - отправка объектов на удалённый репозиторий
    - `--all` - пуш всех веток
    - `--prune` - удаляет удалённые ветки, у которых нет локальных копий
    
    - `-n`/`--dry-run` - показывает, что должна сделать данная, но само действие не выполняется
    - `-d`/`--delete` - удаляет все перечисленные ссылки из удаленного репозитория
    - `--tags` - отправляет перечисленные теги
    - [ ] --follow-tags
    - [ ] --atomic / --no-atomic
    - [ ] -o < option >/--push-option=< option >
    - [ ] --receive-pack=< git-receive-pack >/--exec=< git-receive-pack >
    - [ ] --force-with-lease=< refname >[:< expect >]
    - [ ] --no-force-with-lease
    - `-f`/`--force` - выполнение команды игнонируя возможные потери изменений на удаленной ветке
    - `-u`/`--set-upstream` - добавление upstream'а для каждой ветки
    - [ ] --[no-]thin
    - `-v/--verbose` - вывод более детальной информации
    - `-q/-quite` - вывод только ошибок и предупреждений, игнорируя остальной вывод
    - `--progress` - выводить прогресс в stderr
    - `--recurse-submodules=check|on-demand|only|no` - проверка, обновлены ли сабмодули до последнего комита. Если нет - абортит выполнение
    - `--[no-]verify` - включает/отключает [pre-push hook](https://git-scm.com/docs/githooks)
    <!--Симс лайк дичь-->
    - --mirror
    - 
<!--Не забыть добавить-->
- [ ] remote (управление репозиториями)

# Inspection
- [ ] show (отображает различные типы объектов)
    - `-p`/-`patch` - отображать изменения как патч
    - `--format=<format>` - выбор формата вывода (oneline, short, medium...)
    - `--encoding=<encoding>` <!--Проверить, что это работает--> - использовать кодировку
    - [ ] `--notes[=<treeish>]`/`--no-notes` - 

- [ ] [log](https://git-scm.com/docs/git-log) - вывод логов коммитов
    - [ ] --follow
    - [ ] `--decorate[=short|full|auto|no]`
        - `short` - префиксы не будут выводиться
        - `full` - полный вывод
        - `auto` - если вызов с терминала - `short`, иначе `no` 
    - [ ] --source
    - [ ] --fulldiff
    - `--log-size` - ограничение на длинну комит мессенджа в байтах
    - `-q/-quite` - вывод только ошибок и предупреждений, игнорируя остальной вывод
    - --use-mailmap 
    - --graph (вывод дерева коммитов в виде графа)

# Administration       
- [ ] fsck: проверяет объекты в базе данных
    - --unreachable: вывод всех объектов, которые существуют, но не доступны ни с одной ноды (reference nodes)
    - --[no-]dangling: вывод всех объектов, которые существуют, но никогда не используются напрямую
    - [ ] --** root**: TODO: ?? (Report root nodes.)
    - [ ] --**tags**: TODO: ?? (Report tags.)
    - --cache: 
    -  -v, --verbose
    - --reflogs
    - --full
    - --connectivity-only
    - --strict
    - --lost-found
    - --name-objects
    - --progress

- [x] gc - удаление ненужных файлов и оптимизация репозитория
    - `--aggressive` - агрессивная(более детальная) оптимизация по памяти
    - `--auto` - проверяет, нужно ли выполнять сборку. Если нет - завершает выполнение команыд
    - `--[no-]prune=<date>` - удаляет свободные объекты старше даты (по дефолту 2 недели) / не удалять объекты
    - `-q/-quite` - вывод только ошибок и предупреждений, игнорируя остальной вывод
    - `--force` - запускать gc, даже если в этом репозитории может быть еще один экземпляр gc

- [x] **instaweb** (встроенная утилита, для просмотра состояния репозитория в браузере)
    - -l, --local (запустить на 127.0.0.1)  
    -  -p, --port ...  (номер, на котором запустить сервер)
    -  -d, --httpd ... (команда для запуска)
    -  -b, --browser ... (имя браузера, в котором запустить сервер)
    -Действия
        - --stop (выключить сервер)
        - --start (включить сервер)
        - --restart (перезапустить сервер)

- [ ] archive (создание архива файлов из указанного дерева)
    - `--format=<fmt>` (формат архива, tar по-умолчанию)
    - `-l`/`--list` (все доступные типы архива)
    - `-v`/`--verbose` (информация с stderr)
    - `--prefix=<prefix>/` (префикс для каждого файла в архиве)
    - `-o <file>`/`--output=<file>` (запись архива в указанный файл вместо stdout)
    - `--remote=<repo>` (создание архива с удаленного сервера, а не локального дерева)
    - `<tree-ish>` - дерево или коммит, который нужно архивировать
    - [ ] `<path>`

- [x] [prune](https://git-scm.com/docs/git-prune) - удаляет все недостижимые объекты с базы данных объектов
    - `-n`/`--dry-run` - не выполнять удаление, вывод списока недостижимых файлов
    - `--progress` - выводить прогресс
    - `--expire <time>` - удалять только те файлы, которые старше чем указанное время

# Plumbing Commands
- [ ] [cat-file](https://git-scm.com/docs/git-cat-file) (получение содержимого объекта по хешу)
    - `<object>` - имя объекта для отображения
    - [ ] `<type>` - обычно это соответствует реальному типу `<object>`, но также допускается запрос типа, который может быть тривиально разыменован из данного `<object>`
    - `-t` - вместо содержимого вывести тип объекта
    - `-s` - вместо содержимого вывести размер объекта
    - `-p` - вывод содержимого `<object>` в удобном виде в зависимости от его типа.
    - `-e` - выход с нулевым статусом, если `<object>` существует и является допустимым объектом, иначе выход с ненулевым значением и запуск ошибки в stderr.
    - [ ] `--textconv` - показать содержимое, преобразованное с помощью фильтра textconv. В этом случае `<object>` должен иметь вид `<tree-ish>:<path>` или `:<path>`, чтобы применить фильтр к содержимому, записанному в индексе, по адресу `<path>`.
    - [ ] `--filters` - Покажите содержимое, преобразованное фильтрами, сконфигурированными в текущем рабочем дереве для данного `<path>`. В этом случае `<object>` должен иметь вид `<tree-ish>:<path>` или `:<path>`
    - `--path=<path>` - для использования с `--textconv` или `--filters`, чтобы разрешить указание имени объекта и пути отдельно
    - `--allow-unknown-type` (позволяет использовать ключи -s и -t для повреждённых объектов неизвестного типа)
    - `--buffer` - с помощью этой опции при выводе используется обычная буферизация stdio
    - `--batch[=<format>]` - вывести информацию об объекте и содержимое для каждого объекта, предоставленного на stdin. 
    - `--batch-check[=<format>]` - вывести информацию об объекте для каждого объекта, предоставленного на stdin.
    - [ ] `--batch-all-objects` - Вместо чтения списка объектов на stdin выполните запрошенную пакетную операцию для всех объектов в репозитории и любых хранилищ альтернативных объектов (а не только для достижимых объектов). Требуется указать -batch или -batch-check. Обратите внимание, что объекты посещаются в порядке сортировки по их хэшам.
    - [ ] `--follow-symlinks` - c помощью -batch или -batch-check следуйте символическим ссылкам внутри репозитория
    - [ ] `--unordered` - rогда -batch-all-objects используются, просматривайте объекты в порядке, который может быть более эффективным для доступа к содержимому объекта, чем хеш-порядок.

- [ ] [ls-tree](https://git-scm.com/docs/git-ls-tree) - список элементов дерева объектов
    - `-d` - показывать только деревья
    - `-r` - рекурсивно выводить поддеревья
    - `-t` - инфомация о дереве для `-r`
    - `-l`/`--long` - выводит размер объекта
    - `--name-only`/`--name-status` - выводить только названия файлов
    - `--full-name` - выводить полный путь до файла
    - [ ] `--full-tree` - <!--Чет я не уверен-->вывести всё дерево целиком, а не только данную директорию
    - [ ] --abbrev[=<n>]

- [x] [grep]("https://git-scm.com/docs/git-grep") (вывод строк, подходящих под указанный паттерн)
    - `--cached` - поиск blob'ов, зарегистрированных в индексном файле
    - `--no-index` - поиск файлов в текущем каталоге, который не управляется Git
    - `--untracked` - поиск в индексируемых и неиндексируемых файлах
    - `--exclude-standard` - игнорирование файлов, описанных в .gitignore
    - `--recurse-submodules` - рекурсивно искать в каждом подмодуле